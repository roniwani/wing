local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/BlizTBr/scripts/main/Orion%20X"))()
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local U = {
    GetPolyhedronPattern = function(c, r, n, o, h, pType)
        local v = {}
        local vertices = {}
        if pType == "Tetrahedron" then
            local a = r * 0.816
            vertices = {{0,r,0},{a,-r/3,0},{-a/2,-r/3,a*0.866},{-a/2,-r/3,-a*0.866}}
        elseif pType == "Cube" then
            local s = r * 0.577
            for x = -1, 1, 2 do for y = -1, 1, 2 do for z = -1, 1, 2 do
                table.insert(vertices, {x*s, y*s, z*s})
            end end end
        elseif pType == "Octahedron" then
            vertices = {{r,0,0},{-r,0,0},{0,r,0},{0,-r,0},{0,0,r},{0,0,-r}}
        elseif pType == "Dodecahedron" then
            local phi = (1 + math.sqrt(5)) / 2
            local s = r / math.sqrt(3)
            for x = -1, 1, 2 do for y = -1, 1, 2 do for z = -1, 1, 2 do
                table.insert(vertices, {x*s, y*s, z*s})
                table.insert(vertices, {0, x*s*phi, y*s/phi})
                table.insert(vertices, {x*s/phi, 0, y*s*phi})
                table.insert(vertices, {x*s*phi, y*s/phi, 0})
            end end end
        else
            local phi = (1 + math.sqrt(5)) / 2
            local s = r / 2
            for x = -1, 1, 2 do for y = -1, 1, 2 do for z = -1, 1, 2 do
                table.insert(vertices, {0, x*s, y*s*phi})
                table.insert(vertices, {x*s, y*s*phi, 0})
                table.insert(vertices, {x*s*phi, 0, y*s})
            end end end
        end
        for i = 1, n do
            local idx = ((i - 1) % #vertices) + 1
            local vert = vertices[idx]
            local rotCF = CFrame.Angles(0, o, 0)
            local pos = c + Vector3.new(0, h, 0) + rotCF:VectorToWorldSpace(Vector3.new(vert[1], vert[2], vert[3]))
            table.insert(v, {Position = pos, CFrame = CFrame.lookAt(pos, c + Vector3.new(0, h, 0))})
        end
        return v
    end,
    GetStarPolyPattern = function(c, r, n, o, h, points, layers)
        local v = {}
        for layer = 1, layers do
            local layerR = r * (layer / layers)
            local layerH = h + (layer - 1) * 2
            local toysInLayer = math.floor(n / layers)
            for i = 1, toysInLayer do
                local angle = (i - 1) / toysInLayer * math.pi * 2 + o
                local starAngle = angle * points
                local rad = layerR * (1 + 0.5 * math.cos(starAngle))
                local x = c.X + math.cos(angle) * rad
                local z = c.Z + math.sin(angle) * rad
                local y = c.Y + layerH
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        end
        return v
    end,
    GetLissajousPattern = function(c, r, n, o, h, a, b, delta)
        local v = {}
        for i = 1, n do
            local t = (i - 1) / n * math.pi * 2 + o
            local x = c.X + r * math.sin(a * t + delta)
            local y = c.Y + h + r * 0.5 * math.sin(b * t)
            local z = c.Z + r * math.cos(a * t + delta)
            table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
        end
        return v
    end,
    GetFractalPattern = function(c, r, n, o, h, fType, depth)
        local v = {}
        if fType == "Sierpinski" then
            local function sierpinski(cx, cy, cz, size, d)
                if d == 0 or #v >= n then
                    table.insert(v, {Position = Vector3.new(cx, cy, cz), CFrame = CFrame.lookAt(Vector3.new(cx, cy, cz), c + Vector3.new(0, h, 0))})
                    return
                end
                local s = size / 2
                sierpinski(cx, cy + s, cz, s, d - 1)
                sierpinski(cx - s, cy - s, cz - s, s, d - 1)
                sierpinski(cx + s, cy - s, cz - s, s, d - 1)
                sierpinski(cx, cy - s, cz + s, s, d - 1)
            end
            sierpinski(c.X, c.Y + h, c.Z, r, depth)
        elseif fType == "Koch" then
            for i = 1, n do
                local t = (i - 1) / n
                local angle = t * math.pi * 2 + o
                local iterations = math.min(depth, 3)
                local length = r / (3 ^ iterations)
                local x = c.X + math.cos(angle) * r * t
                local z = c.Z + math.sin(angle) * r * t
                local y = c.Y + h + math.sin(angle * 3 ^ iterations) * length
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        else
            for i = 1, n do
                local t = (i - 1) / n
                local angle = t * math.pi * 2 + o
                local rad = r * (0.5 + 0.5 * math.cos(angle * depth))
                local x = c.X + math.cos(angle) * rad
                local z = c.Z + math.sin(angle) * rad
                local y = c.Y + h
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        end
        return v
    end,
    GetAlchemyPattern = function(c, r, n, o, h, circles, rings)
        local v = {}
        local toysPerCircle = math.floor(n / circles)
        for circ = 1, circles do
            local circR = r * (circ / circles)
            for ring = 1, rings do
                local ringH = h + (ring - 1) * 1.5
                local toysInRing = math.floor(toysPerCircle / rings)
                for i = 1, toysInRing do
                    local angle = (i - 1) / toysInRing * math.pi * 2 + o * circ
                    local x = c.X + math.cos(angle) * circR
                    local z = c.Z + math.sin(angle) * circR
                    local y = c.Y + ringH
                    table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
                end
            end
        end
        return v
    end,
    Get3DMagicPattern = function(c, r, n, o, h)
        local v = {}
        local layers = 5
        local toysPerLayer = math.floor(n / layers)
        for layer = 1, layers do
            local layerH = h + (layer - 1) * 3
            local layerR = r * (1.2 - layer * 0.15)
            local tilt = math.rad((layer - 1) * 20)
            for i = 1, toysPerLayer do
                local angle = (i - 1) / toysPerLayer * math.pi * 2 + o * layer
                local localPos = Vector3.new(math.cos(angle) * layerR, 0, math.sin(angle) * layerR)
                local tiltCF = CFrame.Angles(tilt, 0, math.rad(layer * 30))
                local finalCF = CFrame.new(c + Vector3.new(0, layerH, 0)) * CFrame.Angles(0, o, 0) * tiltCF * CFrame.new(localPos)
                table.insert(v, {Position = finalCF.Position, CFrame = finalCF})
            end
        end
        return v
    end,
    GetAtomPattern = function(c, r, n, o, h)
        local v = {}
        local nucleus = math.floor(n * 0.1)
        local electrons = n - nucleus
        local orbits = 3
        for i = 1, nucleus do
            local angle = ((i - 1) / nucleus) * math.pi * 2 + o
            local rad = r * 0.1
            local x = c.X + math.cos(angle) * rad
            local z = c.Z + math.sin(angle) * rad
            local y = c.Y + h
            table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
        end
        local ePerOrbit = math.floor(electrons / orbits)
        for orb = 1, orbits do
            local tilt = (orb - 1) * math.rad(60)
            local orbitRad = r * (0.3 + orb * 0.2)
            for i = 1, ePerOrbit do
                local t = (i - 1) / ePerOrbit
                local angle = t * math.pi * 2 + o * orb
                local localPos = Vector3.new(math.cos(angle) * orbitRad, 0, math.sin(angle) * orbitRad)
                local tiltCF = CFrame.Angles(tilt, 0, 0)
                local finalCF = CFrame.new(c + Vector3.new(0, h, 0)) * CFrame.Angles(0, o, 0) * tiltCF * CFrame.new(localPos)
                table.insert(v, {Position = finalCF.Position, CFrame = finalCF})
            end
        end
        return v
    end,
    GetTrianglePattern = function(c, r, n, o, h, ang)
        local v = {}
        local points = 3
        for i = 1, n do
            local progress = (i - 1) / n
            local currentPoint = math.floor(progress * points)
            local nextPoint = (currentPoint + 1) % points
            local t = (progress * points) % 1
            local angle1 = (currentPoint / points) * math.pi * 2 + o + math.pi / 2
            local angle2 = (nextPoint / points) * math.pi * 2 + o + math.pi / 2
            local x1 = c.X + math.cos(angle1) * r
            local z1 = c.Z + math.sin(angle1) * r
            local x2 = c.X + math.cos(angle2) * r
            local z2 = c.Z + math.sin(angle2) * r
            local x = x1 + (x2 - x1) * t
            local z = z1 + (z2 - z1) * t
            local p = Vector3.new(x, c.Y + h, z)
            local l = CFrame.lookAt(p, c + Vector3.new(0, h, 0))
            table.insert(v, {Position = p, CFrame = l})
        end
        return v
    end,
    GetSurroundingVectors = function(c, r, a, o, h, ang)
        local v = {}
        for i = 1, a do
            local an = ((i - 1) / a) * math.pi * 2 + o
            local x = c.X + math.cos(an) * r
            local z = c.Z + math.sin(an) * r
            local p = Vector3.new(x, c.Y + h, z)
            local l = CFrame.lookAt(p, c + Vector3.new(0, h, 0))
            local rot = l * CFrame.Angles(math.rad(ang), 0, 0)
            table.insert(v, {Position = p, CFrame = rot})
        end
        return v
    end,
    GetStarPattern = function(c, r, n, o, h, ang)
        local v = {}
        local points = 5
        for i = 1, n do
            local t = (i - 1) / n
            local pointIdx = math.floor(t * points * 2)
            local isOuter = pointIdx % 2 == 0
            local angle = (pointIdx / (points * 2)) * math.pi * 2 + o
            local rad = isOuter and r or (r * 0.382)
            local x = c.X + math.cos(angle) * rad
            local z = c.Z + math.sin(angle) * rad
            local p = Vector3.new(x, c.Y + h, z)
            local l = CFrame.lookAt(p, c + Vector3.new(0, h, 0))
            table.insert(v, {Position = p, CFrame = l})
        end
        return v
    end,
    GetHeartPattern = function(c, s, n, o, h, ang)
        local v = {}
        for i = 1, n do
            local t = ((i - 1) / n) * math.pi * 2 - math.pi + o
            local x = 16 * math.sin(t)^3
            local y = 13 * math.cos(t) - 5 * math.cos(2*t) - 2 * math.cos(3*t) - math.cos(4*t)
            local px = c.X + x * s
            local pz = c.Z + y * s
            local p = Vector3.new(px, c.Y + h, pz)
            local l = CFrame.lookAt(p, c + Vector3.new(0, h, 0))
            table.insert(v, {Position = p, CFrame = l})
        end
        return v
    end,
    GetSpherePattern = function(c, r, n, o, h)
        local v = {}
        local g = (1 + math.sqrt(5)) / 2
        for i = 1, n do
            local t = 2 * math.pi * i / g + o
            local p = math.acos(1 - 2 * (i / n))
            local x = c.X + r * math.sin(p) * math.cos(t)
            local y = c.Y + h + r * math.cos(p)
            local z = c.Z + r * math.sin(p) * math.sin(t)
            local pos = Vector3.new(x, y, z)
            table.insert(v, {Position = pos, CFrame = CFrame.lookAt(pos, c + Vector3.new(0, h, 0))})
        end
        return v
    end,
    GetMagicCirclePattern = function(c, r, n, o, h, ang, lm, ls, cts, ly, rotX, rotY, rotZ, innerLaunch)
        local v = {}
        local toysPerType = math.floor(n / #cts)
        local startIdx = 1
        for _, ct in ipairs(cts) do
            local endIdx = startIdx + toysPerType - 1
            if ct == #cts then endIdx = n end
            local typeCount = endIdx - startIdx + 1
            if ct == 1 then
            local b = 6
            local tpb = math.floor(typeCount / (b + 1))
            local cent = typeCount - (tpb * b)
            for i = 1, cent do
                local a = ((i - 1) / cent) * math.pi * 2 - o
                local rad = r * 0.15
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    if innerLaunch then
                        y = y + ld
                        rad = math.max(rad * (1 - ld / (r * 5)), r * 0.05)
                    else
                        y = y + ld
                        rad = rad + ld * 0.3
                    end
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                local pos = Vector3.new(x, y, z)
                local rotCF = CFrame.Angles(math.rad(rotX), math.rad(rotY), math.rad(rotZ))
                local finalPos = c + Vector3.new(0, h, 0) + rotCF:VectorToWorldSpace(pos - c - Vector3.new(0, h, 0))
                table.insert(v, {Position = finalPos, CFrame = CFrame.lookAt(finalPos, c + Vector3.new(0, h, 0))})
            end
            for br = 1, b do
                local ba = ((br - 1) / b) * math.pi * 2 + o
                for i = 1, tpb do
                    local t = i / tpb
                    local rad = r * t * 0.9
                    local x = c.X + math.cos(ba) * rad
                    local z = c.Z + math.sin(ba) * rad
                    local y = c.Y + h
                    if i % 3 == 0 then
                        local sa = math.rad(45)
                        x = x + math.cos(ba + sa) * r * 0.1
                        z = z + math.sin(ba + sa) * r * 0.1
                    end
                    if lm then
                        local ld = (o * ls) % (r * 5)
                        y = y + ld
                        rad = rad * (1 - ld / (r * 5))
                        x = c.X + math.cos(ba) * rad
                        z = c.Z + math.sin(ba) * rad
                    end
                    table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
                end
            end
        elseif ct == 8 then
            local midCount = math.floor(typeCount * 0.45)
            local outerCount = math.floor(typeCount * 0.25)
            local innerCount = typeCount - midCount - outerCount
            local tilt = math.rad(40)
            for i = 1, midCount do
                local t = (i - 1) / midCount
                local angle = t * math.pi * 2 + o
                local localPos = Vector3.new(math.cos(angle) * r * 0.6, 0, math.sin(angle) * r * 0.6)
                local tiltCF = CFrame.Angles(tilt, 0, 0)
                local rotateCF = CFrame.Angles(0, o * 1.5, 0)
                local finalCF = CFrame.new(c + Vector3.new(0, h, 0)) * rotateCF * tiltCF * CFrame.new(localPos)
                table.insert(v, {Position = finalCF.Position, CFrame = finalCF})
            end
            for i = 1, outerCount do
                local t = (i - 1) / outerCount
                local angle = t * math.pi * 2 - o * 0.5
                local x = c.X + math.cos(angle) * r * 1.2
                local z = c.Z + math.sin(angle) * r * 1.2
                local y = c.Y + h + 0.5
                local pos = Vector3.new(x, y, z)
                table.insert(v, {Position = pos, CFrame = CFrame.new(pos) * CFrame.Angles(0, -angle + math.pi/2, 0)})
            end
            for i = 1, innerCount do
                local t = (i - 1) / innerCount
                local angle = t * math.pi * 2 + o * 3
                local x = c.X + math.cos(angle) * r * 0.2
                local z = c.Z + math.sin(angle) * r * 0.2
                local y = c.Y + h + 0.5
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        elseif ct == 9 then
            local innerCount = math.floor(typeCount * 0.2)
            local starCount = math.floor(typeCount * 0.5)
            local outerCount = typeCount - innerCount - starCount
            for i = 1, starCount do
                local t = (i - 1) / starCount
                local angle = t * math.pi * 2 + o
                local rad = r * 0.5 * (1 + 0.4 * math.sin(angle * 3))
                local x = c.X + math.cos(angle) * rad
                local z = c.Z + math.sin(angle) * rad
                local y = c.Y + h
                local pos = Vector3.new(x, y, z)
                table.insert(v, {Position = pos, CFrame = CFrame.new(pos) * CFrame.Angles(0, -angle + math.pi/2, 0)})
            end
            for i = 1, outerCount do
                local t = (i - 1) / outerCount
                local angle = t * math.pi * 2 + o * 0.8
                local rad = r * 1.2
                local x = c.X + math.cos(angle) * rad
                local z = c.Z + math.sin(angle) * rad
                local y = c.Y + h
                local pos = Vector3.new(x, y, z)
                table.insert(v, {Position = pos, CFrame = CFrame.new(pos) * CFrame.Angles(0, angle + math.pi/2, 0)})
            end
            for i = 1, innerCount do
                local t = (i - 1) / innerCount
                local angle = t * math.pi * 2 - o * 2
                local rad = r * 0.1
                local x = c.X + math.cos(angle) * rad
                local z = c.Z + math.sin(angle) * rad
                local y = c.Y + h
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        elseif ct == 10 then
            local outerTri = math.floor(typeCount * 0.4)
            local innerSquare = math.floor(typeCount * 0.4)
            local core = typeCount - outerTri - innerSquare
            for i = 1, outerTri do
                local corner = math.floor((i - 1) / (outerTri / 3))
                local a = (corner / 3) * math.pi * 2 + o + math.pi / 2
                local rad = r * 0.9
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, innerSquare do
                local side = math.floor((i - 1) / (innerSquare / 4))
                local pos = ((i - 1) % (innerSquare / 4)) / (innerSquare / 4)
                local x, z
                local sqR = r * 0.5
                if side == 0 then x = c.X + (pos - 0.5) * sqR * 2 z = c.Z + sqR
                elseif side == 1 then x = c.X + sqR z = c.Z + (0.5 - pos) * sqR * 2
                elseif side == 2 then x = c.X + (0.5 - pos) * sqR * 2 z = c.Z - sqR
                else x = c.X - sqR z = c.Z + (pos - 0.5) * sqR * 2 end
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    local dir = Vector3.new(x - c.X, 0, z - c.Z).Unit
                    local dist = Vector3.new(x - c.X, 0, z - c.Z).Magnitude * (1 - ld / (r * 5))
                    x = c.X + dir.X * dist
                    z = c.Z + dir.Z * dist
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, core do
                local a = ((i - 1) / core) * math.pi * 2 + o * 2
                local rad = r * 0.15
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        elseif ct == 2 then
            local tpl = math.floor(typeCount / ly)
            for l = 1, ly do
                local lr = r * 0.8
                local tin = tpl + (l == ly and (typeCount % ly) or 0)
                local lo = l % 2 == 0 and -o or o
                local layerHeight = (l - 1) * 2
                for i = 1, tin do
                    local a = ((i - 1) / tin) * math.pi * 2 + lo
                    local x = c.X + math.cos(a) * lr
                    local z = c.Z + math.sin(a) * lr
                    local y = c.Y + h + layerHeight
                    if lm then
                        local ld = (o * ls) % (r * 5)
                        y = y + ld
                        lr = lr * (1 - ld / (r * 5))
                        x = c.X + math.cos(a) * lr
                        z = c.Z + math.sin(a) * lr
                    end
                    table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
                end
            end
        elseif ct == 3 then
            local st = math.floor(typeCount * 0.7)
            local tt = typeCount - st
            for i = 1, st do
                local t = i / st
                local a = t * math.pi * 4 + o
                local rad = r * (0.3 + t * 0.5)
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h + t * r * 0.5
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h + r, 0))})
            end
            for i = 1, tt do
                local a = ((i - 1) / tt) * math.pi * 2 + o * 2
                local x = c.X + math.cos(a) * r * 0.4
                local z = c.Z + math.sin(a) * r * 0.4
                local y = c.Y + h + r * 0.8
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, y, 0))})
            end
        elseif ct == 4 then
            local sq = math.floor(typeCount * 0.3)
            local circ = math.floor(typeCount * 0.4)
            local tri = typeCount - sq - circ
            for i = 1, sq do
                local side = math.floor((i - 1) / (sq / 4))
                local pos = ((i - 1) % (sq / 4)) / (sq / 4)
                local x, z
                if side == 0 then x = c.X + (pos - 0.5) * r * 2 z = c.Z + r
                elseif side == 1 then x = c.X + r z = c.Z + (0.5 - pos) * r * 2
                elseif side == 2 then x = c.X + (0.5 - pos) * r * 2 z = c.Z - r
                else x = c.X - r z = c.Z + (pos - 0.5) * r * 2 end
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    local dir = Vector3.new(x - c.X, 0, z - c.Z).Unit
                    local dist = Vector3.new(x - c.X, 0, z - c.Z).Magnitude
                    dist = dist * (1 - ld / (r * 5))
                    x = c.X + dir.X * dist
                    z = c.Z + dir.Z * dist
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, circ do
                local a = ((i - 1) / circ) * math.pi * 2 - o
                local rad = r * 0.6
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, tri do
                local cor = math.floor((i - 1) / (tri / 3))
                local a = (cor / 3) * math.pi * 2 + o + math.pi / 2
                local rad = r * 0.3
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        elseif ct == 5 then
            local oc = math.floor(typeCount * 0.25)
            local mc = math.floor(typeCount * 0.25)
            local tris = math.floor(typeCount * 0.3)
            local inn = typeCount - oc - mc - tris
            for i = 1, oc do
                local a = ((i - 1) / oc) * math.pi * 2 - o
                local rad = r * 0.95
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, mc do
                local a = ((i - 1) / mc) * math.pi * 2 + o
                local rad = r * 0.6
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for l = 1, 2 do
                local lt = math.floor(tris / 2)
                for i = 1, lt do
                    local cor = math.floor((i - 1) / (lt / 3))
                    local a = (cor / 3) * math.pi * 2 + o * l + math.pi / 2
                    local rad = r * (0.4 + l * 0.1)
                    local x = c.X + math.cos(a) * rad
                    local z = c.Z + math.sin(a) * rad
                    local y = c.Y + h
                    if lm then
                        local ld = (o * ls) % (r * 5)
                        y = y + ld
                        rad = rad * (1 - ld / (r * 5))
                        x = c.X + math.cos(a) * rad
                        z = c.Z + math.sin(a) * rad
                    end
                    table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
                end
            end
            for i = 1, inn do
                local a = ((i - 1) / inn) * math.pi * 2 - o * 2
                local rad = r * 0.15
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        elseif ct == 6 then
            local hx = math.floor(typeCount * 0.4)
            local out = math.floor(typeCount * 0.3)
            local dec = typeCount - hx - out
            for tri = 1, 2 do
                local tt = math.floor(hx / 2)
                for i = 1, tt do
                    local cor = math.floor((i - 1) / (tt / 3))
                    local a = (cor / 3) * math.pi * 2 + (tri == 1 and 0 or math.pi) + o
                    local rad = r * 0.6
                    local x = c.X + math.cos(a) * rad
                    local z = c.Z + math.sin(a) * rad
                    local y = c.Y + h
                    if lm then
                        local ld = (o * ls) % (r * 5)
                        y = y + ld
                        rad = rad * (1 - ld / (r * 5))
                        x = c.X + math.cos(a) * rad
                        z = c.Z + math.sin(a) * rad
                    end
                    table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
                end
            end
            for i = 1, out do
                local a = ((i - 1) / out) * math.pi * 2 - o
                local rad = r * 0.9
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, dec do
                local a = ((i - 1) / dec) * math.pi * 2 + o * 2
                local rad = r * 0.3
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h + math.sin(a * 3) * 0.5
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        else
            local st = math.floor(typeCount * 0.35)
            local orb = math.floor(typeCount * 0.35)
            local cent = typeCount - st - orb
            for i = 1, st do
                local cor = math.floor((i - 1) * 6 / st)
                local a = (cor / 6) * math.pi * 2 + o
                local isO = i % 2 == 0
                local rad = r * (isO and 0.7 or 0.4)
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                if lm then
                    local ld = (o * ls) % (r * 5)
                    y = y + ld
                    rad = rad * (1 - ld / (r * 5))
                    x = c.X + math.cos(a) * rad
                    z = c.Z + math.sin(a) * rad
                end
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
            for i = 1, orb do
                local a = ((i - 1) / orb) * math.pi * 2 + o * 3
                local rad = r * 1.1
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h + math.sin(a * 2 + o) * 2
                local tan = a + math.pi / 2
                local ld = Vector3.new(math.cos(tan), 0, math.sin(tan))
                local lcf = CFrame.lookAt(Vector3.new(x, y, z), Vector3.new(x, y, z) + ld)
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = lcf * CFrame.Angles(math.rad(90), 0, math.rad(o * 50))})
            end
            for i = 1, cent do
                local a = ((i - 1) / cent) * math.pi * 2 - o
                local rad = r * 0.2
                local x = c.X + math.cos(a) * rad
                local z = c.Z + math.sin(a) * rad
                local y = c.Y + h
                table.insert(v, {Position = Vector3.new(x, y, z), CFrame = CFrame.lookAt(Vector3.new(x, y, z), c + Vector3.new(0, h, 0))})
            end
        end
        startIdx = endIdx + 1
        end
        return v
    end
}

local LocalCharacter = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
LocalPlayer.CharacterAdded:Connect(function(character) LocalCharacter = character end)

local GrabEvents = ReplicatedStorage:WaitForChild("GrabEvents", 10)
local SetNetworkOwner = GrabEvents:WaitForChild("SetNetworkOwner", 5)
local CreateGrabLine = GrabEvents:WaitForChild("CreateGrabLine", 5)
local DestroyGrabLine = GrabEvents:WaitForChild("DestroyGrabLine", 5)

local toysFolder = workspace:FindFirstChild(LocalPlayer.Name.."SpawnedInToys")

local function getPlotItems()
    local items = {}
    local plotItems = workspace:FindFirstChild("PlotItems")
    if plotItems then
        for i = 1, 5 do
            local plot = plotItems:FindFirstChild("Plot"..i)
            if plot then
                for _, item in pairs(plot:GetChildren()) do
                    if (item:IsA("Model") or item:IsA("BasePart")) and item.Name ~= "ToysLimitNum" then
                        table.insert(items, item)
                    end
                end
            end
        end
    end
    return items
end

local patternSpeed = 0.1
local patternRadius = 20
local patternOffset = 0
local patternHeight = 0
local patternAngleX = 0
local patternAngleY = 0
local patternAngleZ = 0
local patternType = "Circle"
local includeAllToys = false

local magicCircleType = 1
local magicCircleTypes = {1}
local magicCircleLaunch = false
local magicCircleRotX = 0
local magicCircleRotY = 0
local magicCircleRotZ = 0
local magicInnerLaunch = true

local polyhedronType = "Tetrahedron"
local polyhedronRotSpeed = 0.05
local starPolyPoints = 5
local starPolyLayers = 3

local lissajousA = 3
local lissajousB = 4
local lissajousDelta = math.pi / 2

local fractalType = "Sierpinski"
local fractalDepth = 3

local alchemyCircles = 5
local alchemyRings = 3
local launchSpeed = 50
local magicCircleRotation = true
local magicCircleLayers = 3

local toyOrbitConnection = nil
local toyParts = {}
local bodyPositions = {}
local alignOrientations = {}
local usePlotItems = false
local attachToPlayer = false
local attachedPlayerName = "自分"

local playerLoopEnabled = false
local playerLoopConnection = nil
local playerRadius = 20
local grabbedPlayers = {}
local targetPlayerName = "全員"
local excludeSelf = true
local bringToFront = false
local noRotation = false

local wingsEnabled = false
local wingsConnection = nil
local wingParts = {}
local wingXSpacing = 3
local wingYOffset = 0
local wingZOffset = -2
local wingAngleHorizontal = 0
local wingAngleVertical = 0
local wingFlapEnabled = false
local wingFlapSpeed = 2
local wingFlapRange = 30
local wingFlapTime = 0
local useToysForWings = true

local haloEnabled = false
local haloConnection = nil
local haloPart = nil
local haloRadius = 2
local haloHeight = 3
local haloSpeed = 0.05

local function sno(player, cf)
    pcall(function()
        if SetNetworkOwner and CreateGrabLine then
            SetNetworkOwner:FireServer(player, cf)
            CreateGrabLine:FireServer(player, cf)
        end
    end)
end

local function ungrab(player)
    pcall(function()
        if DestroyGrabLine then DestroyGrabLine:FireServer(player) end
    end)
end

local function maintainGrab(targetHead)
    local maintainConnection
    local lastValidCFrame = targetHead.CFrame
    maintainConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not targetHead or not targetHead.Parent then
                if maintainConnection then maintainConnection:Disconnect() end
                return
            end
            local currentCFrame = targetHead.CFrame
            if (currentCFrame.Position - lastValidCFrame.Position).Magnitude > 10 then
                targetHead.CFrame = lastValidCFrame
            else
                lastValidCFrame = currentCFrame
            end
            local partOwner = targetHead:FindFirstChild("PartOwner")
            if not partOwner or partOwner.Value ~= LocalPlayer.Name then
                sno(targetHead, targetHead.CFrame)
            end
            targetHead.CanCollide = false
        end)
    end)
    return maintainConnection
end

local function getPart(v)
    if v:IsA("BasePart") then
        return v
    elseif v:IsA("Model") then
        local part = v:FindFirstChild("SoundPart") or v:FindFirstChild("FireworkSparkler") or v:FindFirstChild("Handle") or v:FindFirstChild("Main") or v.PrimaryPart
        if not part then
            for _, child in pairs(v:GetDescendants()) do
                if child:IsA("BasePart") and child.Name ~= "HumanoidRootPart" then
                    return child
                end
            end
        end
        return part
    end
    return nil
end

local function startToyOrbit()
    toyParts = {}
    bodyPositions = {}
    alignOrientations = {}
    pcall(function()
        local toysToOrbit = {}
        if usePlotItems then
            toysToOrbit = getPlotItems()
        elseif includeAllToys then
            for _, folder in pairs(workspace:GetChildren()) do
                if folder.Name:match("SpawnedInToys$") then
                    for _, toy in pairs(folder:GetChildren()) do
                        if toy.Name ~= "ToyNumber" then table.insert(toysToOrbit, toy) end
                    end
                end
            end
        else
            if toysFolder then
                for _, toy in pairs(toysFolder:GetChildren()) do
                    if toy.Name ~= "ToyNumber" then table.insert(toysToOrbit, toy) end
                end
            end
        end
        for i, v in pairs(toysToOrbit) do
            local part = getPart(v)
            if part then
                table.insert(toyParts, part)
                if v:IsA("Model") then
                    for _, p in pairs(v:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = false end
                    end
                else
                    part.CanCollide = false
                end
                local bp = Instance.new("BodyPosition")
                bp.P = 15000
                bp.D = 200
                bp.MaxForce = Vector3.new(5000000, 5000000, 5000000)
                bp.Parent = part
                bp.Position = part.Position
                table.insert(bodyPositions, bp)
                local ao = Instance.new("AlignOrientation")
                ao.MaxTorque = 400000
                ao.Mode = Enum.OrientationAlignmentMode.OneAttachment
                ao.Responsiveness = 2000
                ao.Parent = part
                table.insert(alignOrientations, ao)
                local att = Instance.new("Attachment")
                att.Parent = part
                ao.Attachment0 = att
            end
        end
        toyOrbitConnection = RunService.Heartbeat:Connect(function()
            pcall(function()
                local centerCharacter = LocalCharacter
                if attachToPlayer and attachedPlayerName ~= "自分" then
                    local targetPlayer = Players:FindFirstChild(attachedPlayerName)
                    if targetPlayer and targetPlayer.Character then
                        centerCharacter = targetPlayer.Character
                    end
                end
                if not centerCharacter or not centerCharacter:FindFirstChild("HumanoidRootPart") then return end
                patternOffset = patternOffset + patternSpeed
                local positions
                if patternType == "Circle" then
                    positions = U.GetSurroundingVectors(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, patternAngleX)
                elseif patternType == "Star" then
                    positions = U.GetStarPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, 5, patternOffset, patternHeight, patternAngleX)
                elseif patternType == "Heart" then
                    positions = U.GetHeartPattern(centerCharacter.HumanoidRootPart.Position, patternRadius / 20, #toyParts, patternOffset, patternHeight, patternAngleX)
                elseif patternType == "MagicCircle" then
                    positions = U.GetMagicCirclePattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, patternAngleX, magicCircleLaunch, launchSpeed, magicCircleTypes, magicCircleLayers, magicCircleRotX, magicCircleRotY, magicCircleRotZ, magicInnerLaunch)
                elseif patternType == "Triangle" then
                    positions = U.GetTrianglePattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, patternAngleX)
                elseif patternType == "Atom" then
                    positions = U.GetAtomPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight)
                elseif patternType == "Polyhedron" then
                    positions = U.GetPolyhedronPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, polyhedronType)
                elseif patternType == "StarPoly" then
                    positions = U.GetStarPolyPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, starPolyPoints, starPolyLayers)
                elseif patternType == "Lissajous" then
                    positions = U.GetLissajousPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, lissajousA, lissajousB, lissajousDelta)
                elseif patternType == "Fractal" then
                    positions = U.GetFractalPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, fractalType, fractalDepth)
                elseif patternType == "Alchemy" then
                    positions = U.GetAlchemyPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight, alchemyCircles, alchemyRings)
                elseif patternType == "3DMagic" then
                    positions = U.Get3DMagicPattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight)
                elseif patternType == "Sphere" then
                    positions = U.GetSpherePattern(centerCharacter.HumanoidRootPart.Position, patternRadius, #toyParts, patternOffset, patternHeight)
                end
                for i, data in ipairs(positions) do
                    if bodyPositions[i] and toyParts[i] then
                        bodyPositions[i].Position = data.Position
                        if alignOrientations[i] then alignOrientations[i].CFrame = data.CFrame end
                    end
                end
            end)
        end)
    end)
end

local function stopToyOrbit()
    pcall(function()
        if toyOrbitConnection then toyOrbitConnection:Disconnect() toyOrbitConnection = nil end
        for _, v in ipairs(bodyPositions) do v:Destroy() end
        for _, v in ipairs(alignOrientations) do v:Destroy() end
        bodyPositions = {}
        alignOrientations = {}
        toyParts = {}
    end)
end

local function startPlayerLoop()
    grabbedPlayers = {}
    playerLoopConnection = RunService.Heartbeat:Connect(function()
        pcall(function()
            if not LocalCharacter or not LocalCharacter:FindFirstChild("HumanoidRootPart") then return end
            local myPos = LocalCharacter.HumanoidRootPart.Position
            local nearbyPlayers = {}
            for _, player in pairs(Players:GetPlayers()) do
                if excludeSelf and player == LocalPlayer then continue end
                if targetPlayerName ~= "全員" and player.Name ~= targetPlayerName then continue end
                if player.Character then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    local head = player.Character:FindFirstChild("Head")
                    if hrp and head and (hrp.Position - myPos).Magnitude <= playerRadius then
                        table.insert(nearbyPlayers, {Player = player, HRP = hrp, Head = head})
                        if not grabbedPlayers[player.Name] then
                            sno(head, head.CFrame)
                            grabbedPlayers[player.Name] = {maintainConn = maintainGrab(head), head = head}
                        end
                    end
                end
            end
            if #nearbyPlayers > 0 then
                if not bringToFront then patternOffset = patternOffset + patternSpeed end
                local positions
                if bringToFront then
                    positions = {}
                    local spacing = 3
                    local startX = -(#nearbyPlayers - 1) * spacing / 2
                    for i = 1, #nearbyPlayers do
                        local xOffset = startX + (i - 1) * spacing
                        local frontPos = myPos + (LocalCharacter.HumanoidRootPart.CFrame.LookVector * 5)
                        table.insert(positions, {Position = frontPos + Vector3.new(xOffset, patternHeight, 0), CFrame = CFrame.new()})
                    end
                else
                    if patternType == "Circle" then
                        positions = U.GetSurroundingVectors(myPos, playerRadius, #nearbyPlayers, patternOffset, patternHeight, patternAngleX)
                    elseif patternType == "Star" then
                        positions = U.GetStarPattern(myPos, playerRadius, 5, patternOffset, patternHeight, patternAngleX)
                    elseif patternType == "Heart" then
                        positions = U.GetHeartPattern(myPos, playerRadius / 20, #nearbyPlayers, patternOffset, patternHeight, patternAngleX)
                    elseif patternType == "MagicCircle" then
                        positions = U.GetMagicCirclePattern(myPos, playerRadius, #nearbyPlayers, patternOffset, patternHeight, patternAngleX, magicCircleLaunch, launchSpeed, magicCircleTypes, magicCircleLayers)
                    elseif patternType == "Triangle" then
                        positions = U.GetTrianglePattern(myPos, playerRadius, #nearbyPlayers, patternOffset, patternHeight, patternAngleX)
                    elseif patternType == "Atom" then
                        positions = U.GetAtomPattern(myPos, playerRadius, #nearbyPlayers, patternOffset, patternHeight)
                    elseif patternType == "Sphere" then
                        positions = U.GetSpherePattern(myPos, playerRadius, #nearbyPlayers, patternOffset, patternHeight)
                    end
                end
                for i, data in ipairs(positions) do
                    if nearbyPlayers[i] then
                        if noRotation then
                            nearbyPlayers[i].HRP.CFrame = CFrame.new(data.Position)
                        else
                            nearbyPlayers[i].HRP.CFrame = CFrame.new(data.Position) * data.CFrame.Rotation
                        end
                        nearbyPlayers[i].Head.CanCollide = false
                    end
                end
            end
        end)
    end)
end

local function stopPlayerLoop()
    pcall(function()
        if playerLoopConnection then playerLoopConnection:Disconnect() playerLoopConnection = nil end
        for playerName, data in pairs(grabbedPlayers) do
            if data.maintainConn then data.maintainConn:Disconnect() end
            ungrab(data.head)
        end
        grabbedPlayers = {}
    end)
end

local function createWings()
    wingParts = {}
    pcall(function()
        local toysToUse = {}
        if useToysForWings then
            if toysFolder then
                for _, toy in pairs(toysFolder:GetChildren()) do
                    if toy.Name ~= "ToyNumber" then table.insert(toysToUse, toy) end
                end
            end
        else
            toysToUse = getPlotItems()
        end
        if #toysToUse == 0 then return end
        local wingsCount = #toysToUse
        if haloEnabled and wingsCount % 2 == 1 then wingsCount = wingsCount - 1 end
        for i = 1, wingsCount do
            local v = toysToUse[i]
            local part = getPart(v)
            if part then
                table.insert(wingParts, part)
                if v:IsA("Model") then
                    for _, p in pairs(v:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = false end
                    end
                else
                    part.CanCollide = false
                end
                
                local bp = Instance.new("BodyPosition")
                bp.P = 15000
                bp.D = 200
                bp.MaxForce = Vector3.new(5000000, 5000000, 5000000)
                bp.Parent = part
                bp.Position = part.Position
                table.insert(bodyPositions, bp)
                
                local ao = Instance.new("AlignOrientation")
                ao.MaxTorque = 400000
                ao.Mode = Enum.OrientationAlignmentMode.OneAttachment
                ao.Responsiveness = 2000
                ao.Parent = part
                table.insert(alignOrientations, ao)
                
                local att = Instance.new("Attachment")
                att.Parent = part
                ao.Attachment0 = att
            end
        end
        wingsConnection = RunService.Heartbeat:Connect(function()
            pcall(function()
                if not LocalCharacter or not LocalCharacter:FindFirstChild("HumanoidRootPart") then return end
                local cf = LocalCharacter.HumanoidRootPart.CFrame
                if wingFlapEnabled then wingFlapTime = wingFlapTime + (wingFlapSpeed * 0.05) end
                local halfCount = math.floor(#wingParts / 2)
                for i, part in ipairs(wingParts) do
                    local isLeft = i <= halfCount
                    local indexInSide = isLeft and i or (i - halfCount)
                    local distMulti = indexInSide / math.max(halfCount, 1)
                    local flapValue = wingFlapEnabled and math.sin(wingFlapTime - (indexInSide - 1) * 0.05) or 0
                    local yMove = flapValue * (wingFlapRange * 0.2) * distMulti
                    local angleZ = flapValue * wingFlapRange * distMulti
                    local xOffset = (isLeft and -1 or 1) * (indexInSide - 0.5) * wingXSpacing
                    local wingCF = cf * CFrame.new(xOffset, wingYOffset + yMove, wingZOffset)
                    
                    if bodyPositions[i] then
                        bodyPositions[i].Position = wingCF.Position
                    end
                    if alignOrientations[i] then
                        alignOrientations[i].CFrame = wingCF * CFrame.Angles(math.rad(wingAngleVertical), (isLeft and -1 or 1) * math.rad(wingAngleHorizontal), (isLeft and -1 or 1) * math.rad(angleZ))
                    end
                end
            end)
        end)
    end)
end

local function destroyWings()
    pcall(function()
        if wingsConnection then wingsConnection:Disconnect() wingsConnection = nil end
        for _, v in ipairs(bodyPositions) do
            if v and v.Parent then v:Destroy() end
        end
        for _, v in ipairs(alignOrientations) do
            if v and v.Parent then v:Destroy() end
        end
        wingParts = {}
        wingFlapTime = 0
    end)
end

local function createHalo()
    pcall(function()
        local toysToUse = {}
        if useToysForWings then
            if toysFolder then
                for _, toy in pairs(toysFolder:GetChildren()) do
                    if toy.Name ~= "ToyNumber" then table.insert(toysToUse, toy) end
                end
            end
        else
            toysToUse = getPlotItems()
        end
        if #toysToUse % 2 == 1 then
            local toy = toysToUse[#toysToUse]
            local part = getPart(toy)
            if part then
                if toy:IsA("Model") then
                    for _, p in pairs(toy:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = false end
                    end
                else
                    part.CanCollide = false
                end
                local bp = Instance.new("BodyPosition")
                bp.P = 15000
                bp.D = 200
                bp.MaxForce = Vector3.new(5000000, 5000000, 5000000)
                bp.Parent = part
                
                local ao = Instance.new("AlignOrientation")
                ao.MaxTorque = 400000
                ao.Mode = Enum.OrientationAlignmentMode.OneAttachment
                ao.Responsiveness = 2000
                ao.Parent = part
                
                local att = Instance.new("Attachment")
                att.Parent = part
                ao.Attachment0 = att
                
                haloPart = {Part = part, BP = bp, AO = ao}
                
                local haloOffset = 0
                haloConnection = RunService.Heartbeat:Connect(function()
                    pcall(function()
                        if not LocalCharacter or not LocalCharacter:FindFirstChild("Head") then return end
                        local head = LocalCharacter.Head
                        haloOffset = haloOffset + haloSpeed
                        local x = math.cos(haloOffset) * haloRadius
                        local z = math.sin(haloOffset) * haloRadius
                        local haloPos = head.Position + Vector3.new(x, haloHeight, z)
                        haloPart.BP.Position = haloPos
                        haloPart.AO.CFrame = CFrame.lookAt(haloPos, head.Position + Vector3.new(0, haloHeight, 0))
                    end)
                end)
            end
        end
    end)
end

local function destroyHalo()
    pcall(function()
        if haloConnection then haloConnection:Disconnect() haloConnection = nil end
        if haloPart then
            if haloPart.BP then haloPart.BP:Destroy() end
            if haloPart.AO then haloPart.AO:Destroy() end
            haloPart = nil
        end
    end)
end

task.wait(1)
local Window = OrionLib:MakeWindow({Name = "🎨 おもちゃ＆プレイヤー操作 v5", HidePremium = false, SaveConfig = true, ConfigFolder = "ToyPlayerControlV5", IntroEnabled = false})

local ToyTab = Window:MakeTab({Name = "🎨 おもちゃ＆設定", Icon = "rbxassetid://4483345998", PremiumOnly = false})
ToyTab:AddSection({Name = "🌟 パターン選択"})
ToyTab:AddDropdown({Name = "軌道パターン", Default = "Circle", Options = {"Circle", "Star", "Heart", "Triangle", "Atom", "MagicCircle", "Sphere", "Polyhedron", "StarPoly", "Lissajous", "Fractal", "Alchemy", "3DMagic"}, Callback = function(Value) patternType = Value end})
ToyTab:AddSection({Name = "⚙️ 共通設定"})
ToyTab:AddSlider({Name = "⚡ 速度", Min = 0.05, Max = 1, Default = 0.1, Color = Color3.fromRGB(255,255,255), Increment = 0.05, ValueName = "", Callback = function(Value) patternSpeed = Value end})
ToyTab:AddSlider({Name = "📏 半径", Min = 5, Max = 100, Default = 20, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) patternRadius = Value playerRadius = Value end})
ToyTab:AddSlider({Name = "📐 X軸角度", Min = -90, Max = 90, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) patternAngleX = Value end})
ToyTab:AddSlider({Name = "🔄 Y軸角度", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) patternAngleY = Value end})
ToyTab:AddSlider({Name = "↩️ Z軸角度", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) patternAngleZ = Value end})
ToyTab:AddSlider({Name = "📊 高さ", Min = -50, Max = 50, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) patternHeight = Value end})
ToyTab:AddSection({Name = "✨ おもちゃパターン"})
local function getToyPlayerList()
    local list = {"自分"}
    for _, player in pairs(Players:GetPlayers()) do table.insert(list, player.Name) end
    return list
end
ToyTab:AddToggle({Name = "👤 プレイヤーに付ける", Default = false, Callback = function(Value) attachToPlayer = Value end})
ToyTab:AddDropdown({Name = "対象プレイヤー", Default = "自分", Options = getToyPlayerList(), Callback = function(Value) attachedPlayerName = Value end})
ToyTab:AddButton({Name = "🔄 プレイヤーリスト更新", Callback = function() OrionLib:MakeNotification({Name = "更新完了", Content = "プレイヤーリストが更新されました", Time = 2}) end})
ToyTab:AddToggle({Name = "🏠 Plotアイテム使用", Default = false, Callback = function(Value) usePlotItems = Value if toyOrbitConnection then stopToyOrbit() startToyOrbit() end end})
ToyTab:AddToggle({Name = "🌍 全員のおもちゃ", Default = false, Callback = function(Value) includeAllToys = Value if toyOrbitConnection then stopToyOrbit() startToyOrbit() end end})
ToyTab:AddToggle({Name = "✨ パターン起動", Default = false, Callback = function(Value) if Value then startToyOrbit() else stopToyOrbit() end end})

local MagicTab = Window:MakeTab({Name = "🔮 魔法陣テスト", Icon = "rbxassetid://4483345998", PremiumOnly = false})
MagicTab:AddSection({Name = "✨ 魔法陣タイプ"})
MagicTab:AddToggle({Name = "魔法陣1 - 雪の結晶", Default = true, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 1) then table.insert(magicCircleTypes, 1) end
    else for i, v in ipairs(magicCircleTypes) do if v == 1 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣2 - 多重円", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 2) then table.insert(magicCircleTypes, 2) end
    else for i, v in ipairs(magicCircleTypes) do if v == 2 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣3 - スパイラル光柱", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 3) then table.insert(magicCircleTypes, 3) end
    else for i, v in ipairs(magicCircleTypes) do if v == 3 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣4 - 錬金術基礎", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 4) then table.insert(magicCircleTypes, 4) end
    else for i, v in ipairs(magicCircleTypes) do if v == 4 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣5 - 複雑錬金術", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 5) then table.insert(magicCircleTypes, 5) end
    else for i, v in ipairs(magicCircleTypes) do if v == 5 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣6 - 六芒星", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 6) then table.insert(magicCircleTypes, 6) end
    else for i, v in ipairs(magicCircleTypes) do if v == 6 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣7 - 天体六芒星", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 7) then table.insert(magicCircleTypes, 7) end
    else for i, v in ipairs(magicCircleTypes) do if v == 7 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣8 - 3D傾斜オービット", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 8) then table.insert(magicCircleTypes, 8) end
    else for i, v in ipairs(magicCircleTypes) do if v == 8 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣9 - 平面六芒星", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 9) then table.insert(magicCircleTypes, 9) end
    else for i, v in ipairs(magicCircleTypes) do if v == 9 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddToggle({Name = "魔法陣10 - 外三角内四角", Default = false, Callback = function(Value)
    if Value then if not table.find(magicCircleTypes, 10) then table.insert(magicCircleTypes, 10) end
    else for i, v in ipairs(magicCircleTypes) do if v == 10 then table.remove(magicCircleTypes, i) break end end end
end})
MagicTab:AddSection({Name = "🚀 発射設定"})
MagicTab:AddToggle({Name = "🚀 発射モード", Default = false, Callback = function(Value) magicCircleLaunch = Value end})
MagicTab:AddToggle({Name = "📍 内側から発射", Default = true, Callback = function(Value) magicInnerLaunch = Value end})
MagicTab:AddSlider({Name = "🚀 発射速度", Min = 10, Max = 100, Default = 50, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) launchSpeed = Value end})
MagicTab:AddSection({Name = "⚙️ 魔法陣設定"})
MagicTab:AddSlider({Name = "🔄 層の数", Min = 2, Max = 10, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) magicCircleLayers = Value end})
MagicTab:AddSlider({Name = "🔄 X軸回転", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) magicCircleRotX = Value end})
MagicTab:AddSlider({Name = "🔄 Y軸回転", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) magicCircleRotY = Value end})
MagicTab:AddSlider({Name = "🔄 Z軸回転", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) magicCircleRotZ = Value end})
MagicTab:AddToggle({Name = "🔄 魔法陣回転", Default = true, Callback = function(Value) magicCircleRotation = Value end})

local GeoTab = Window:MakeTab({Name = "📐 幾何学", Icon = "rbxassetid://4483345998", PremiumOnly = false})
GeoTab:AddSection({Name = "🔷 正多面体"})
GeoTab:AddDropdown({Name = "多面体タイプ", Default = "Tetrahedron", Options = {"Tetrahedron", "Cube", "Octahedron", "Dodecahedron", "Icosahedron"}, Callback = function(Value) polyhedronType = Value end})
GeoTab:AddSlider({Name = "回転速度", Min = 0.01, Max = 0.2, Default = 0.05, Color = Color3.fromRGB(255,255,255), Increment = 0.01, ValueName = "", Callback = function(Value) polyhedronRotSpeed = Value end})
GeoTab:AddSection({Name = "⭐ 星型多面体"})
GeoTab:AddSlider({Name = "星の数", Min = 3, Max = 12, Default = 5, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) starPolyPoints = Value end})
GeoTab:AddSlider({Name = "層の数", Min = 1, Max = 10, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) starPolyLayers = Value end})
GeoTab:AddSection({Name = "🌀 リサジュー図形"})
GeoTab:AddSlider({Name = "A係数", Min = 1, Max = 10, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) lissajousA = Value end})
GeoTab:AddSlider({Name = "B係数", Min = 1, Max = 10, Default = 4, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) lissajousB = Value end})
GeoTab:AddSlider({Name = "位相差", Min = 0, Max = 360, Default = 90, Color = Color3.fromRGB(255,255,255), Increment = 15, ValueName = "", Callback = function(Value) lissajousDelta = math.rad(Value) end})
GeoTab:AddSection({Name = "🔺 フラクタル"})
GeoTab:AddDropdown({Name = "フラクタルタイプ", Default = "Sierpinski", Options = {"Sierpinski", "Koch", "Mandelbrot"}, Callback = function(Value) fractalType = Value end})
GeoTab:AddSlider({Name = "深度", Min = 1, Max = 5, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) fractalDepth = Value end})
GeoTab:AddSection({Name = "⚗️ 錬金術の円"})
GeoTab:AddSlider({Name = "円の数", Min = 2, Max = 10, Default = 5, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) alchemyCircles = Value end})
GeoTab:AddSlider({Name = "リングの数", Min = 1, Max = 5, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 1, ValueName = "", Callback = function(Value) alchemyRings = Value end})

local WingTab = Window:MakeTab({Name = "🪽 羽テスト", Icon = "rbxassetid://4483345998", PremiumOnly = false})
WingTab:AddSection({Name = "🪽 羽機能"})
WingTab:AddToggle({Name = "🏠 Plotアイテム使用", Default = false, Callback = function(Value) useToysForWings = not Value if wingsEnabled then destroyWings() createWings() end if haloEnabled then destroyHalo() createHalo() end end})
WingTab:AddToggle({Name = "🪽 羽を展開", Default = false, Callback = function(Value) wingsEnabled = Value if Value then createWings() else destroyWings() end end})
WingTab:AddSection({Name = "📏 羽の配置"})
WingTab:AddSlider({Name = "横間隔", Min = 1, Max = 30, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) wingXSpacing = Value end})
WingTab:AddSlider({Name = "高さ調整", Min = -5, Max = 5, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) wingYOffset = Value end})
WingTab:AddSlider({Name = "前後調整", Min = -10, Max = 10, Default = -2, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) wingZOffset = Value end})
WingTab:AddSection({Name = "🔄 羽の角度"})
WingTab:AddSlider({Name = "横角度", Min = -180, Max = 180, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) wingAngleHorizontal = Value end})
WingTab:AddSlider({Name = "縦角度", Min = -90, Max = 90, Default = 0, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) wingAngleVertical = Value end})
WingTab:AddSection({Name = "🦅 羽ばたき"})
WingTab:AddToggle({Name = "🦅 羽ばたきON/OFF", Default = false, Callback = function(Value) wingFlapEnabled = Value if not Value then wingFlapTime = 0 end end})
WingTab:AddSlider({Name = "羽ばたき速度", Min = 0.5, Max = 5, Default = 2, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) wingFlapSpeed = Value end})
WingTab:AddSlider({Name = "羽ばたき大きさ", Min = 10, Max = 90, Default = 30, Color = Color3.fromRGB(255,255,255), Increment = 5, ValueName = "", Callback = function(Value) wingFlapRange = Value end})

local HaloTab = Window:MakeTab({Name = "👑 頭上リング", Icon = "rbxassetid://4483345998", PremiumOnly = false})
HaloTab:AddToggle({Name = "👑 リング起動", Default = false, Callback = function(Value) haloEnabled = Value if Value then if wingsEnabled then destroyWings() createWings() end createHalo() else destroyHalo() if wingsEnabled then destroyWings() createWings() end end end})
HaloTab:AddSlider({Name = "リング半径", Min = 1, Max = 5, Default = 2, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) haloRadius = Value end})
HaloTab:AddSlider({Name = "リング高さ", Min = 1, Max = 5, Default = 3, Color = Color3.fromRGB(255,255,255), Increment = 0.5, ValueName = "", Callback = function(Value) haloHeight = Value end})
HaloTab:AddSlider({Name = "回転速度", Min = 0.01, Max = 0.5, Default = 0.05, Color = Color3.fromRGB(255,255,255), Increment = 0.01, ValueName = "", Callback = function(Value) haloSpeed = Value end})

local PlayerTab = Window:MakeTab({Name = "🎯 プレイヤー操作", Icon = "rbxassetid://4483345998", PremiumOnly = false})
PlayerTab:AddSection({Name = "👥 プレイヤー選択"})
PlayerTab:AddToggle({Name = "自分を除外", Default = true, Callback = function(Value) excludeSelf = Value if playerLoopEnabled then stopPlayerLoop() startPlayerLoop() end end})
local function getPlayerList()
    local list = {"全員"}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then table.insert(list, player.Name) end
    end
    return list
end
PlayerTab:AddDropdown({Name = "対象プレイヤー", Default = "全員", Options = getPlayerList(), Callback = function(Value) targetPlayerName = Value if playerLoopEnabled then stopPlayerLoop() startPlayerLoop() end end})
PlayerTab:AddButton({Name = "🔄 プレイヤーリスト更新", Callback = function() OrionLib:MakeNotification({Name = "更新完了", Content = "プレイヤーリストが更新されました", Time = 2}) end})
PlayerTab:AddSection({Name = "🌐 ループ移動"})
PlayerTab:AddToggle({Name = "📍 目の前に配置", Default = false, Callback = function(Value) bringToFront = Value end})
PlayerTab:AddToggle({Name = "🔒 回転なし", Default = false, Callback = function(Value) noRotation = Value end})
PlayerTab:AddToggle({Name = "🔁 ループ起動", Default = false, Callback = function(Value) playerLoopEnabled = Value if Value then startPlayerLoop() else stopPlayerLoop() end end})

local SettingsTab = Window:MakeTab({Name = "⚙️ 設定", Icon = "rbxassetid://4483345998", PremiumOnly = false})
SettingsTab:AddButton({Name = "UI破棄", Callback = function() stopToyOrbit() stopPlayerLoop() destroyWings() destroyHalo() OrionLib:Destroy() end})

OrionLib:Init()
